#!/usr/bin/env ruby

THIS_SPANBAR_EXECUTABLE_FILE = File.symlink?(__FILE__) ? File.readlink(__FILE__) : __FILE__
THIS_PATH_REL = File.dirname(THIS_SPANBAR_EXECUTABLE_FILE)
THIS_PATH = File.absolute_path(THIS_PATH_REL)

require THIS_PATH + '/../lib/spanbars.rb'


# prepare processing of incoming control commands (e.g. Ctrl-C)
Signal.trap("TERM") { local_interrupt }
Signal.trap("INT")  { local_interrupt }

def local_interrupt
  exit
end

# prepare command line parser and help text

op = Slop::Options.new
op.banner = "\n#{"Usage:".light_white} spanbars [options]"
op.separator "" 
op.bool    '--simple'   , "Disable processing of strict StanBars", default: false
op.float   '--ticksize' , "Set ticksize for processing",           default: 1.0
op.integer '--span'     , "Set span for processing",               default: 10
op.boolean  '--ohlc'     , "Define OHLC input file instead of timeseries (overrides --simple and --both)", default: false
op.boolean '--human'    , "Define human output",                   default: false
op.boolean '--intraday' , "Strip date portion (affects --human only)", default: false
op.boolean '--help'     , "Print this help", default: false
op.boolean '--both'     , "Returns both simple and strict bars (overrides --simple)",   default: false
op.integer '--time'     , "The column in CSV providing the timestamp, defaults to the first", default: 0
op.integer '--value'    , "The column in CSV providing the value, defaults to the second", default: 1
op.integer '--volume'   , "The column in CSV providing the volume, default to the third",  default: 2
op.separator "" 
op.separator "#{"Please note:".light_white} spanbars relies on STDIN data, e.g. "
op.separator "    #{"$".light_white} cat /tmp/timeseries.csv | spanbars --simple --span 5 --ticksize 0.1"
op.separator ""

optparser = Slop::Parser.new(op)

# print help upon unparsable commandline options
begin
  opts = optparser.parse(ARGV)
rescue StandardError => e
  puts e.inspect
  puts op.to_s
  exit
end

if opts.help? 
  puts op.to_s
  exit
end

unless STDIN.tty? 
  unless opts.ohlc?
    s = SpanBarProcessor.new(opts)
    while csv = STDIN.gets
      line   = CSV.parse(csv.chomp).flatten
      result = s.add(line[opts[:time]].to_i, line[opts[:value]].to_f, line[opts[:volume]].to_i)
      if result
        if opts[:human] 
          result.each {|r| r.set_intraday if opts[:intraday]; puts ([:up, :bottom].include? r.type) ? "#{r.to_human}".green : "#{r.to_human}".red } 
        else # CSV output
          result.each {|r| CSV {|out| out << r.to_a  } }
        end
      end
    end
    exit
  else # if ohlc is given
    data = [ ] 
    data << CSV.parse(csv.chomp).flatten while csv = STDIN.gets
    opts = opts.to_hash
    opts.delete(:simple)
    opts.delete(:both)
    highOpts = opts.dup
    highOpts[:span] = (opts[:span] / 2.0).floor.to_i
    highProc = SpanBarProcessor.new(highOpts)
    lowProc  = SpanBarProcessor.new(highOpts)
    finProc  = SpanBarProcessor.new(opts)
    data.each do |d| 
      highProc.add(d[0].to_i, d[2].to_f, d[5].to_i)
      lowProc. add(d[0].to_i, d[3].to_f, d[5].to_i)
    end
    highs = highProc.spanBars.map{|bar| bar.type.to_s.downcase == "up"   ? bar.highval : nil } 
    lows  =  lowProc.spanBars.map{|bar| bar.type.to_s.downcase == "down" ? nil :  bar.lowval } 
    res = [ highs, lows ].flatten.compact
    res.sort!{|a,b| a[:t] <=> b[:t]}
    res.each {|peak| finProc.add peak[:t],peak[:p], peak[:v]}
    if opts[:human]
      finProc.spanBars.each {|r| r.set_intraday if opts[:intraday]; puts ([:up, :bottom].include? r.type) ? "#{r.to_human}".green : "#{r.to_human}".red }
    else # CSV output
      finProc.spanBars.each {|r| CSV {|out| out << r.to_a  } }
    end
  end
else
  puts op.to_s
end





